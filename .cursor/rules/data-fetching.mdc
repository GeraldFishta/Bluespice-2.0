---
alwaysApply: true
---

# Data Fetching Rules - Bluespice 2.0

## Overview

SWR for GET requests and caching, Supabase for mutations with separated hooks pattern, pessimistic updates, centralized cache management, and centralized error handling for the Bluespice payroll application.

## Core Principles

### 1. SWR for GET Operations

- Use SWR exclusively for data fetching and caching
- Configure SWR globally for consistent behavior
- Implement automatic revalidation strategies
- Handle loading and error states uniformly

### 2. Separated Hooks Pattern

- **CRITICAL**: Always separate data fetching hooks from mutation hooks
- Data fetching hooks (`useEmployees`, `usePayroll`) → Data fetching ONLY
- Mutation hooks (`useEmployeeMutations`, `usePayrollMutations`) → Mutations ONLY
- This prevents unnecessary fetches when you only need mutations

### 3. Centralized Cache Management

- Use centralized cache modules in `lib/cache/` organized by feature
- Don't use `mutate()` directly in components or mutation hooks
- Use cache modules like `employeesCache.invalidateEmployee(id)`
- Implement selective cache invalidation

### 4. Error Handling

- Centralized error handling with toast notifications
- Consistent error response format
- Graceful degradation for network failures
- User-friendly error messages

## Patterns & Examples

### Separation of Data Fetching and Mutations

**CRITICAL**: Always separate data fetching hooks from mutation hooks. This prevents unnecessary fetches when you only need mutations.

```javascript
// ✅ GOOD: Separated hooks pattern
// hooks/useEmployees.ts - Data fetching ONLY
"use client";
import useSWR from "swr";
import { supabase } from "@/lib/supabase";

export function useEmployees(params = {}) {
  const key = employeesKey(params);
  const {
    data,
    isLoading,
    error,
    mutate: refetch,
  } = useSWR(key, () => fetchEmployeesWithParams(params), {
    revalidateOnFocus: false,
  });

  return {
    employees: data?.data || [],
    total: data?.count ?? null,
    isLoading,
    error,
    mutate: refetch,
    // NO mutations here - use useEmployeeMutations() instead
  };
}

// hooks/useEmployeeMutations.ts - Mutations ONLY
("use client");
import { supabase } from "@/lib/supabase";
import { useToast } from "./useToast";
import { employeesCache } from "@/lib/cache";

export function useEmployeeMutations() {
  const toast = useToast();

  const createEmployee = async (employeeData) => {
    try {
      const { data, error } = await supabase
        .from("employees")
        .insert(employeeData)
        .select()
        .single();

      if (error) throw error;

      // Use centralized cache module
      employeesCache.invalidateEmployeeLists();
      toast.success("Employee created successfully!");
      return { success: true, data };
    } catch (error) {
      toast.error(error.message || "Failed to create employee");
      return { success: false, error: error.message };
    }
  };

  const updateEmployee = async (id, employeeData) => {
    try {
      const { data, error } = await supabase
        .from("employees")
        .update(employeeData)
        .eq("id", id)
        .select()
        .single();

      if (error) throw error;

      employeesCache.invalidateEmployee(id);
      toast.success("Employee updated successfully!");
      return { success: true, data };
    } catch (error) {
      toast.error(error.message || "Failed to update employee");
      return { success: false, error: error.message };
    }
  };

  const deleteEmployee = async (id) => {
    try {
      const { error } = await supabase.from("employees").delete().eq("id", id);

      if (error) throw error;

      employeesCache.invalidateEmployeeLists();
      toast.success("Employee deleted successfully!");
      return { success: true };
    } catch (error) {
      toast.error(error.message || "Failed to delete employee");
      return { success: false, error: error.message };
    }
  };

  return {
    createEmployee,
    updateEmployee,
    deleteEmployee,
    // NO data fetching - use useEmployees() instead
  };
}

// Usage examples:
// ✅ GOOD: Only fetch what you need
const EmployeeDetailPage = () => {
  const { employee } = useEmployee(id); // Fetch single employee
  const { deleteEmployee } = useEmployeeMutations(); // Only mutations, no fetch
  // No unnecessary list fetch!
};

// ✅ GOOD: Fetch list when needed
const EmployeesListPage = () => {
  const { employees, isLoading } = useEmployees({ page: 1, pageSize: 20 });
  const { deleteEmployee } = useEmployeeMutations();
  // Both hooks used appropriately
};
```

### Centralized Cache Management

Cache invalidation should be handled by centralized cache modules in `lib/cache/`, organized by feature.

```javascript
// lib/cache/employees.ts - Centralized employee cache management
import { mutate as globalMutate } from "swr";
import type { SWRKey } from "./types";
import { isListKey, logCacheOperation } from "./utils";

const EMPLOYEES_LIST_PREFIX = "employees";
const EMPLOYEE_DETAIL_PREFIX = "employee-";

/**
 * Invalidate only employee list caches (not detail endpoints)
 * Use after create/delete operations or bulk updates
 */
export function invalidateEmployeeLists() {
  logCacheOperation("Employees", "Invalidating employee lists only");

  globalMutate((key: SWRKey) => {
    if (isListKey(key, EMPLOYEES_LIST_PREFIX)) {
      return true;
    }
    return false;
  });
}

/**
 * Invalidate a specific employee detail cache
 * Use after updating a single employee
 */
export function invalidateEmployee(employeeId: string) {
  logCacheOperation("Employees", "Invalidating employee cache", { employeeId });

  // Invalidate detail cache
  globalMutate(`${EMPLOYEE_DETAIL_PREFIX}${employeeId}`);

  // Also invalidate lists since the employee might appear there
  invalidateEmployeeLists();
}

// Export as cohesive module
export const employeesCache = {
  invalidateEmployeeLists,
  invalidateEmployee,
  invalidateEmployees,
  invalidateAllEmployees,
  updateEmployeeCache,
};

// Usage in mutations:
import { employeesCache } from "@/lib/cache";

const updateEmployee = async (id, data) => {
  await supabase.from("employees").update(data).eq("id", id);
  employeesCache.invalidateEmployee(id); // Centralized, type-safe
};
```

**File Structure for Cache Modules:**

```
lib/
├── cache/
│   ├── index.ts           # Export all cache modules
│   ├── types.ts           # Shared types for cache keys
│   ├── utils.ts           # Shared utilities (isListKey, logCacheOperation)
│   ├── employees.ts       # Employee cache management
│   ├── payroll.ts        # Payroll cache management
│   └── departments.ts    # Department cache management
```

### Single Resource Hook

```javascript
// hooks/useEmployees.ts
export function useEmployee(id: string | null) {
  const fetchEmployee = async (): Promise<Employee | null> => {
    if (!id) return null;

    const { data, error } = await supabase
      .from("employee_dto_v1")
      .select("*")
      .eq("id", id)
      .single();

    if (error) throw error;
    return (data as Employee) || null;
  };

  const { data: employee, isLoading, error } = useSWR<Employee | null>(
    id ? `employee-${id}` : null,
    fetchEmployee
  );

  return {
    employee: employee || null,
    isLoading,
    error,
  };
}
```

### SWR Configuration

```javascript
// lib/swr-config.js
import { SWRConfig } from "swr";

const swrConfig = {
  revalidateOnFocus: false,
  revalidateOnReconnect: false,
  dedupingInterval: 2000,
  errorRetryCount: 3,
  errorRetryInterval: 5000,
  onError: (error) => {
    console.error("SWR Error:", error);
    // Global error handling
  },
};

export const SWRProvider = ({ children }) => {
  return <SWRConfig value={swrConfig}>{children}</SWRConfig>;
};
```

### Error Handling with Toast

```javascript
// hooks/useToast.js (example)
import { toast } from "react-toastify";

export const useToast = () => {
  return {
    success: (message) => toast.success(message),
    error: (message) => toast.error(message),
    info: (message) => toast.info(message),
    warning: (message) => toast.warning(message),
  };
};
```

### Toast Notification Pattern

**CRITICAL**: Mutation hooks handle toast notifications for CRUD operations. Components should NOT show duplicate toasts.

**Pattern:**
- **Mutation Hooks** (`useEmployeeMutations`, `usePayrollMutations`) → Show success/error toasts for create/update/delete operations
- **Components** → Only show toasts for:
  - Form validation errors (via `useFormErrors`)
  - Special operations that don't go through mutation hooks (e.g., API routes)
  - Component-specific messages that aren't handled by mutations

```javascript
// ✅ GOOD: Mutation hook handles toast
// hooks/useEmployeeMutations.ts
const updateEmployee = async (id, data) => {
  try {
    await supabase.from("employees").update(data).eq("id", id);
    employeesCache.invalidateEmployee(id);
    toast.success("Employee updated successfully!"); // ✅ Toast here
    return { success: true };
  } catch (error) {
    toast.error(error.message || "Failed to update employee");
    return { success: false, error: error.message };
  }
};

// ✅ GOOD: Component doesn't duplicate toast
// components/employees/EmployeeForm.tsx
const result = await updateEmployee(employee.id, data);
if (!result.success) throw new Error(result.error);
// No toast here - mutation hook already showed it ✅
router.push("/employees");

// ❌ BAD: Component duplicates toast
const result = await updateEmployee(employee.id, data);
toast.success("Employee updated successfully!"); // ❌ Duplicate!
router.push("/employees");
```

## Anti-Patterns

### ❌ Don't Do This

```javascript
// ❌ DON'T: Mix data fetching and mutations in the same hook
const BadUseEmployees = () => {
  const { data, error, isLoading } = useSWR("/api/employees", fetcher);

  // This triggers a fetch even when you only need deleteEmployee!
  const deleteEmployee = async (id) => {
    await api.delete(`/api/employees/${id}`);
    mutate("/api/employees");
  };

  return { employees: data, isLoading, error, deleteEmployee };
};

// Usage in detail page - causes unnecessary list fetch:
const EmployeeDetailPage = () => {
  const { employee } = useEmployee(id);
  const { deleteEmployee } = useEmployees(); // ❌ Fetches list unnecessarily!
};

// ❌ DON'T: Invalidate cache directly in mutations
const BadAddEmployee = async (employeeData) => {
  await api.post("/api/employees", employeeData);
  mutate("/api/employees"); // ❌ Direct mutate in mutation hook
  // Should use centralized cache module instead
};

// ❌ DON'T: Use optimistic updates for payroll data
const BadUpdateEmployee = async (id, data) => {
  // Optimistically update UI
  setEmployees((prev) =>
    prev.map((emp) => (emp.id === id ? { ...emp, ...data } : emp))
  );

  try {
    await api.put(`/api/employees/${id}`, data);
  } catch (error) {
    // Rollback on error - complex and error-prone
    setEmployees(originalEmployees);
  }
};

// ❌ DON'T: Mix fetch and supabase/axios
const BadDataFetching = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("/api/employees") // Inconsistent with supabase usage
      .then((res) => res.json())
      .then(setData);
  }, []);
};

// ❌ DON'T: Show duplicate toast notifications
const BadUpdateEmployee = async () => {
  const result = await updateEmployee(id, data);
  if (result.success) {
    toast.success("Employee updated!"); // ❌ Duplicate! Hook already showed it
  }
};
```

### ✅ Do This Instead

```javascript
// ✅ GOOD: Separate data fetching from mutations
// hooks/useEmployees.ts - Data fetching ONLY
export function useEmployees(params = {}) {
  const { data, isLoading, error, mutate } = useSWR(employeesKey(params), () =>
    fetchEmployeesWithParams(params)
  );

  return {
    employees: data?.data || [],
    isLoading,
    error,
    mutate,
    // NO mutations here
  };
}

// hooks/useEmployeeMutations.ts - Mutations ONLY
export function useEmployeeMutations() {
  const createEmployee = async (data) => {
    await supabase.from("employees").insert(data);
    employeesCache.invalidateEmployeeLists(); // ✅ Centralized cache
  };

  return { createEmployee, updateEmployee, deleteEmployee };
}

// ✅ GOOD: Use appropriate hooks in components
const EmployeeDetailPage = () => {
  const { employee } = useEmployee(id); // ✅ Fetch single employee
  const { deleteEmployee } = useEmployeeMutations(); // ✅ Only mutations, no fetch
};

// ✅ GOOD: Use pessimistic updates
const GoodUpdateEmployee = async (id, data) => {
  try {
    await supabase.from("employees").update(data).eq("id", id);
    employeesCache.invalidateEmployee(id); // ✅ Centralized cache invalidation
    toast.success("Employee updated successfully");
  } catch (error) {
    toast.error("Failed to update employee");
  }
};

// ✅ GOOD: Always use centralized cache modules
import { employeesCache } from "@/lib/cache";

const GoodAddEmployee = async (employeeData) => {
  try {
    await supabase.from("employees").insert(employeeData);
    employeesCache.invalidateEmployeeLists(); // ✅ Centralized, type-safe
    toast.success("Employee added successfully");
  } catch (error) {
    toast.error("Failed to add employee");
  }
};

// ✅ GOOD: Use consistent data fetching with SWR
const GoodDataFetching = () => {
  const { employees, isLoading, error } = useEmployees({ page: 1 });

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return <EmployeeList employees={employees} />;
};

// ✅ GOOD: Let mutation hook handle toast, component handles navigation
const GoodUpdateEmployee = async () => {
  const result = await updateEmployee(id, data);
  if (!result.success) {
    // Handle error if needed (hook already showed error toast)
    return;
  }
  // No success toast here - hook already showed it ✅
  router.push("/employees");
};
```

## Related Files/Dependencies

### Required Packages

```json
{
  "swr": "^2.0.0",
  "@supabase/supabase-js": "^2.0.0",
  "react-toastify": "^9.0.0"
}
```

### File Structure

```
lib/
├── swr-config.js         # SWR global configuration
├── supabase.js           # Supabase client configuration
├── cache/                # Centralized cache management modules
│   ├── index.ts         # Export all cache modules
│   ├── types.ts         # Shared cache types
│   ├── utils.ts         # Shared cache utilities
│   ├── employees.ts     # Employee cache management
│   ├── payroll.ts       # Payroll cache management
│   └── departments.ts   # Department cache management
hooks/
├── useEmployees.ts       # Employee data fetching ONLY
├── useEmployeeMutations.ts # Employee mutations ONLY
├── useEmployee.ts       # Single employee fetching
├── usePayroll.ts         # Payroll data fetching ONLY
├── usePayrollMutations.ts # Payroll mutations ONLY
├── useToast.js          # Toast notification hook
└── useLoadingStates.js   # Loading states hook (if needed)
```

### Data Fetching Best Practices

1. **Separate Concerns**: Always separate data fetching hooks from mutation hooks

   - `useEmployees()` → Data fetching ONLY
   - `useEmployeeMutations()` → Mutations ONLY
   - This prevents unnecessary fetches when you only need mutations

2. **Centralized Cache**: Use centralized cache modules in `lib/cache/`

   - One module per feature (employees.ts, payroll.ts, etc.)
   - Expose cohesive API (employeesCache.invalidateEmployee())
   - Don't use `mutate()` directly in components/mutations

3. **Global SWR Config**: Set revalidation policies globally
4. **Error Handling**: Implement consistent error handling
5. **Loading States**: Use SWR's built-in loading states
6. **Cache Keys**: Use consistent, descriptive cache keys with key generators
7. **Deduplication**: Leverage SWR's automatic deduplication
8. **Revalidation**: Configure appropriate revalidation strategies

### Hook Naming Convention

- **Data Fetching Hooks**: `useEmployees`, `usePayroll`, `useEmployee(id)`

  - Return: `{ data, isLoading, error, mutate }`
  - NO mutations included

- **Mutation Hooks**: `useEmployeeMutations`, `usePayrollMutations`
  - Return: `{ createX, updateX, deleteX }`
  - NO data fetching (no useSWR inside)
  - Use centralized cache modules for invalidation
